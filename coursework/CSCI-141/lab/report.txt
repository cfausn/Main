1) The purpose of pivot is to create a point where we can orient the larger and smaller lists during the fastSelect() algorithm. 
The middle item doesn't necessarily need to be selected, however it is advisable to do so because it is, in my tests, faster to 
run it this way. If we selected the first item as the pivot each time the function would work absolutely fine, however it would take the 
function more time to complete the task because it isn't using a "divide and conqure" technique like it would if it was in the middle.

2) In order to test the fastSelect() correctly we need to test for each of the kth smallest numbers. for instance:

fastSelect([1,5,7,2,6], 1) should return 2 because the index 1 when sorted holds second smallest number.
fastSelect([1,5,7,2,6], 2) should return 5
fastSelect([1,5,7,2,6], 0) should return 1
fastSelect([1,5,7,2,6], 4) should return 7
fastSelect([1], 2) should return 1
fastSelect([],2) should return [] 

The function can be confusing because k has to work in index form, where 0 is the first place and 1 is the second. This gave me some issues 
myself when coding it into the program.


3)

findSlow.py runs:

Run:		Elapsed Time:

1		23.32391404275722
2		24.323313248198165
3		23.34357091171949
4		24.4256341699981
5		24.849259582105045

findFast.py runs:

Run:		Elapsed Time:

1		0.15520147328461972
2		0.1503665250028042
3		0.15116049755613342
4		0.15105749372996283
5		0.15333824037207475

The algorithm was much faster! While I got the same result from both programs, findFast.py managed to accomplish the task much much quicker
than findSlow.py could do.